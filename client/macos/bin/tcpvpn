#!/bin/bash

# TODO add `update` option
#
# Usage:
# Manage configurations
#     tcpvpn create [-f <filepath>]
#     tcpvpn delete <name>
#     tcpvpn export <name>
#     tcpvpn list
#
# Activate/deactivate the VPN
#     tcpvpn up <name>
#     tcpvpn down <name>
#
# Manage the installation
#     tcpvpn version
#     tcpvpn update
#     tcpvpn uninstall

APPLICATION_SUPPORT_DIR=~/"Library/Application Support/tcpvpn"
BIN_DIRECTORY="/usr/local/bin"
LIB_DIRECTORY="/usr/local/lib/tcpvpn"

INSTALL_SCRIPT_URL="https://raw.githubusercontent.com/coolcoder067/TCP-VPN/refs/heads/main/install/install_client_macos.sh"

CLR_WHITE="\033[1;37m"
CLR_YELLOW="\033[1;33m"
CLR_RED="\033[1;31m"
CLR_RESET="\033[0m"


echo_info() {
	echo -e "${CLR_WHITE}[Info] $*${CLR_RESET}"
}

echo_warn() {
	echo -e "${CLR_YELLOW}[Warn] $*${CLR_RESET}"
}

echo_error() {
	echo -e "${CLR_RED}[Error] $*${CLR_RESET}"
}

get_default_iface() {
	route -n get default 2>/dev/null | awk '/interface:/{print $2}'
}

get_wg_iface() {
	wg show | awk '/interface:/{print $2}'
}

get_ipv4_gateway() {
	route -n get default | grep gateway | awk "{print \$2}"
}

get_ipv6_gateway() {
	route -n get -inet6 default | grep gateway | awk "{print \$2}" 2>/dev/null
}

create_endpoint () {
	f_flag='' # Argument to read from file
	while getopts ':f:' flag; do
		case "${flag}" in
			f) f_flag="$OPTARG" ;;
			:) echo_error "-$OPTARG requires an argument"; echo_info "Usage: tcpvpn create [-f <filename>]"; exit 1 ;;
			\?) echo_error "Invalid option -$OPTARG"; echo_info "Usage: tcpvpn create [-f <filename>]"; exit 1 ;;
		esac
	done
	if [[ -n "$f_flag" ]]; then
		if [[ -f "$f_flag" ]]; then
			source "$f_flag"
		else
			echo_error "File provided does not exist."
			exit 1
		fi
	fi

	cd "$APPLICATION_SUPPORT_DIR"

	# Take input from user
	if [[ -z "${ENDPOINT_ADDRESS// }" ]]; then
		echo -ne 'What is the address of VPN server?\n> '
		read ENDPOINT_ADDRESS
	else
		echo_info 'Reading ENDPOINT_ADDRESS from provided file.'
	fi
	if [[ -z "${ENDPOINT_ADDRESS// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi
	# RESOLVE_WITH_DNS
	if [[ -z "${RESOLVE_WITH_DNS// }" ]]; then
		echo -ne "Does this address need to be resolved with DNS? Answer with 'true' or 'false'.\n> "
		read RESOLVE_WITH_DNS
	else
		echo_info 'Reading RESOLVE_WITH_DNS from provided file.'
	fi
	if [[ -z "${RESOLVE_WITH_DNS// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi
	if [[ "$RESOLVE_WITH_DNS" != "true" && "$RESOLVE_WITH_DNS" != "false" ]]; then
		echo_error "Please enter \"true\" or \"false\" exactly."
		exit 1
	fi

	# ENDPOINT_PORT
	if [[ -z "${ENDPOINT_PORT// }" ]]; then
		echo -ne 'What is the port that the server is listening on?\n> '
		read ENDPOINT_PORT
	else
		echo_info 'Reading ENDPOINT_PORT from provided file.'
	fi
	if [[ -z "${ENDPOINT_PORT// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi

	# USER_PRIVATE_KEY
	if [[ -z "${USER_PRIVATE_KEY// }" ]]; then
		echo -ne 'What is the PRIVATE key of YOUR USER?\n> '
		read USER_PRIVATE_KEY
	else
		echo_info 'Reading USER_PRIVATE_KEY from provided file.'
	fi
	if [[ -z "${USER_PRIVATE_KEY// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi

	# SERVER_PUBLIC_KEY
	if [[ -z "${SERVER_PUBLIC_KEY// }" ]]; then
		echo -ne 'What is the PUBLIC key of the SERVER?\n> '
		read SERVER_PUBLIC_KEY
	else
		echo_info 'Reading SERVER_PUBLIC_KEY from provided file.'
	fi
	if [[ -z "${SERVER_PUBLIC_KEY// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi

	# UDP2RAW_PWD
	if [[ -z "${UDP2RAW_PWD// }" ]]; then
		echo -ne 'What is the password for udp2raw?\n> '
		read UDP2RAW_PWD
	else
		echo_info 'Reading UDP2RAW_PWD from provided file.'
	fi
	if [[ -z "${UDP2RAW_PWD// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi

	# USER_ADDRESS
	if [[ -z "${USER_ADDRESS// }" ]]; then
		echo -ne "Enter the IP addresses allocated to your user, separated by comma.\nThis should look like \"10.0.0.2/24, fd42:42:42::2/64\".\n> "
		read USER_ADDRESS
	else
		echo_info 'Reading USER_ADDRESS from provided file.'
	fi
	if [[ -z "${USER_ADDRESS// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi

	# DNS_SERVERS
	if [[ -z "${DNS_SERVERS// }" ]]; then
		echo -ne "Enter the DNS servers you want to use, separated by comma, or leave blank.\nThe default is \"1.1.1.1, 2606:4700:4700::1111\".\n> "
		read DNS_SERVERS
	else
		echo_info 'Reading DNS_SERVERS from provided file.'
	fi
	if [[ -z "$DNS_SERVERS" ]]; then
		DNS_SERVERS='1.1.1.1, 2606:4700:4700::1111'
	fi

	# WIREGUARD_PORT
	if [[ -z "${WIREGUARD_PORT// }" ]]; then
		echo -ne "Choose an empty port where wireguard and udp2raw can communicate. (ex. 50001)\n> "
		read WIREGUARD_PORT
	else
		echo_info 'Reading WIREGUARD_PORT from provided file.'
	fi
	if [[ -z "${WIREGUARD_PORT// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi

	# CONFIGURATION_NAME
	if [[ -z "${CONFIGURATION_NAME// }" ]]; then
		echo -ne 'What is the name of your new VPN configuration? Keep it short.\n> '
		read CONFIGURATION_NAME
	else
		echo_info 'Reading CONFIGURATION_NAME from provided file.'
	fi
	if [[ -z "${CONFIGURATION_NAME// }" ]]; then
		echo_error "Input cannot be blank."
		exit 1
	fi


	
	CONFIGURATION_DIR="$APPLICATION_SUPPORT_DIR"/endpoints/"$CONFIGURATION_NAME"
	if [[ -d "$CONFIGURATION_DIR" ]]; then
		echo_warn "A configuration with name \"$CONFIGURATION_NAME\" already exists. Proceeding will overwrite that configuration."
	fi
	echo 'Press enter to confirm the details above, or CTRL+C to quit.'
	read

	# Make directory
	rm -rf "$CONFIGURATION_DIR"
	mkdir -p "$CONFIGURATION_DIR"

	# Generate script_env.cfg
	echo -ne "ENDPOINT_ADDRESS='$ENDPOINT_ADDRESS'\nRESOLVE_WITH_DNS='$RESOLVE_WITH_DNS'\n\
ENDPOINT_PORT='$ENDPOINT_PORT'\nUSER_PRIVATE_KEY='$USER_PRIVATE_KEY'\nSERVER_PUBLIC_KEY='$SERVER_PUBLIC_KEY'\n\
UDP2RAW_PWD='$UDP2RAW_PWD'\nUSER_ADDRESS='$USER_ADDRESS'\nDNS_SERVERS='$DNS_SERVERS'\n\
WIREGUARD_PORT='$WIREGUARD_PORT'\nCONFIGURATION_NAME='$CONFIGURATION_NAME'\n\
" > "$CONFIGURATION_DIR"/script_env.cfg

	# Generate wg.conf
	echo -ne "[Interface]\nPrivateKey = $USER_PRIVATE_KEY\n\
Address = $USER_ADDRESS\nDNS = $DNS_SERVERS\nMTU = 1342\n\n\
PostUp = '$LIB_DIRECTORY/PostUp.sh' '$CONFIGURATION_DIR'\n\n\
[Peer]\nPublicKey = $SERVER_PUBLIC_KEY\nAllowedIPs = 0.0.0.0/0, ::/0\n\
Endpoint = 127.0.0.1:$WIREGUARD_PORT\n" > "$CONFIGURATION_DIR"/wg.conf

	echo_info "Generated files at \"$CONFIGURATION_DIR\".\nUse \`sudo tcpvpn up $CONFIGURATION_NAME\` to activate your VPN."
}

# Logic for activation and deactivation
# Will activate if wg is not active and there's an internet connection
# Will deactivate if wg is active, and use the `active` file to determine which one
# Not relying on `active` file to determine IF it's active

activate_endpoint () {
	if [[ -z "$1" ]]; then
		echo_error "Argument <name> required"
		echo_info "Usage: tcpvpn up <name>"
		exit 1
	fi
	if [[ -n "$2" ]]; then
		echo_error "Too many arguments."
		echo_info "Usage: tcpvpn up <name>"
		exit 1
	fi
	if [[ -n $(get_wg_iface) ]]; then
		echo_error "VPN already active. Use \`tcpvpn down\` to deactivate."
		exit 1
	fi
	if [[ -z $(get_default_iface) ]]; then
		echo_error "No Internet connection. Cannot connect to VPN."
		exit 1
	fi
	if [[ ! -f "$APPLICATION_SUPPORT_DIR"/endpoints/"$1"/wg.conf ]]; then
		echo_error "No configuration exists for \"$1\". Use \`tcpvpn create\` to create a configuration."
		exit 1
	fi
	echo_info "Activating configuration \"$1\"..."
	# Proceed with activation
	cd "$APPLICATION_SUPPORT_DIR"/endpoints/"$1"
	source script_env.cfg
	# Save ipv4 Gateway
	ipv4_gw=$(get_ipv4_gateway)
	if [[ -z ipv4_gw ]]; then
		echo_error "No ipv4 gateway. (this should never happen)"
		exit 1
	fi
	echo "$ipv4_gw" > ipv4_gw
	# Save ipv6 gateway if exists
	ipv6_gw=$(get_ipv6_gateway)
	if [[ -n ipv6_gw ]]; then
		echo "$ipv6_gw" > ipv6_gw
	else
		rm -f ipv6_gw
	fi
	# Resolve any DNS
	if [[ "$RESOLVE_WITH_DNS" == true ]]; then
		resolved=$(timeout 1s dig +short "$ENDPOINT_ADDRESS" | head -n 1)
		if [[ -n "$resolved" ]]; then
			echo "$resolved" > resolved_addr
			echo_info "DNS resolution successful."
		else
			if [[ -f "resolved_addr" ]]; then
				echo_info "DNS resolution failed, using cached"
			else
				echo_error "Error: Was not able to resolve \"$ENDPOINT_ADDRESS\""
				exit 1
			fi
		fi
	else
		echo "$ENDPOINT_ADDRESS" > resolved_addr
	fi
	# wg-quick up
	if ! wg-quick up "./wg.conf" > "wg.log" 2>&1; then
		echo_error "wg-quick failed. See \"$(pwd)/wg.log\" for more information."
		exit 1
	fi
	echo $1 > "$APPLICATION_SUPPORT_DIR"/active
	echo_info "Done!"
}


deactivate_endpoint () {
	if [[ -n $1 ]]; then
		echo_error "Too many arguments."
		echo_info "Usage: tcpvpn down"
		exit 1
	fi
	if [[ ! -f "$APPLICATION_SUPPORT_DIR"/active || -z $(get_wg_iface) ]]; then
		echo_error "The VPN is not active. Use \`tcpvpn up <name>\` to activate."
		exit 1
	fi
	ACTIVE_VPN=$(cat "$APPLICATION_SUPPORT_DIR"/active)
	cd "$APPLICATION_SUPPORT_DIR"/endpoints/"$ACTIVE_VPN"
	if [[ ! -f "wg.conf" ]]; then
		echo_error "No file was found at $(pwd)/wg.conf. (this should never happen)"
		exit 1
	fi
	echo_info "Deactivating configuration \"$ACTIVE_VPN\"..."
	if ! wg-quick down "./wg.conf" > "wg.log" 2>&1; then
		echo_error "wg-quick failed. See \"$(pwd)/wg.log\" for more information."
		exit 1
	fi
	killall udp2raw || true
	route -n delete default >/dev/null 2>&1 || true
	route -n delete -inet6 default >/dev/null 2>&1 || true
	# Use the files saved by activate_endpoint to bring back the previous connection
	# ipv4_gw, ipv6_gw
	route -n add default $(cat ipv4_gw) >/dev/null
	if [[ -f ipv6_gw ]]; then
		route -n add -inet6 default $(cat ipv6_gw) >/dev/null
	fi
	route -n delete $(cat resolved_addr) >/dev/null
	# Firewall down
	pfctl -d >/dev/null 2>&1 || true
	echo_info "Done!"
}


uninstall () {
	if [[ -n $1 ]]; then
		echo_error "Too many arguments."
		echo_info "Usage: tcpvpn uninstall"
		exit 1
	fi
	echo_warn 'This option will uninstall the tool completely, erasing all VPN configurations. Type "Yes" exactly to continue.'
	read -p "> " YES_OPTION
	if [[ "$YES_OPTION" = "Yes" ]]; then
		if [[ -f "$BIN_DIRECTORY"/udp2raw ]]; then
			echo "Would you like to uninstall the udp2raw dependency as well? Type \"Yes\" to confirm, or anything else to deny."
			read -p "> " YES_OPTION
			if [[ "$YES_OPTION" = "Yes" ]]; then
				rm -f "$BIN_DIRECTORY"/udp2raw
				echo_info "Uninstalled udp2raw."
			else
				echo_info "Skip uninstall of udp2raw."
			fi
		fi
		rm -f "$BIN_DIRECTORY"/tcpvpn
		rm -rf "$LIB_DIRECTORY"
		rm -rf "$APPLICATION_SUPPORT_DIR"
		echo_info "Done!"
	else
		echo_info "Abort."
	fi
}

export_conf () { # `export` is reserved
	if [[ -z "$1" ]]; then
		echo_error "Argument <name> required"
		echo_info "Usage: tcpvpn export <name>"
		exit 1
	fi
	if [[ -n "$2" ]]; then
		echo_error "Too many arguments."
		echo_info "Usage: tcpvpn export <name>"
		exit 1
	fi
	cd "$APPLICATION_SUPPORT_DIR"
	if [[ ! -f "endpoints/$1/script_env.cfg" ]]; then
		echo_error "No configuration exists for \"$1\". Use \`tcpvpn create\` to create a configuration."
		exit 1
	fi
	cat "endpoints/$1/script_env.cfg"
}

delete () {
	if [[ -z "$1" ]]; then
		echo_error "Argument <name> required"
		echo_info "Usage: tcpvpn delete <name>"
		exit 1
	fi
	if [[ -n "$2" ]]; then
		echo_error "Too many arguments."
		echo_info "Usage: tcpvpn delete <name>"
		exit 1
	fi
	cd "$APPLICATION_SUPPORT_DIR"
	if [[ ! -d "endpoints/$1" ]]; then
		echo_error "No configuration exists for \"$1\". Use \`tcpvpn create\` to create a configuration."
		exit 1
	fi
	read -p "Press enter to permanently delete configuration \"$1\", or Ctrl+C to quit. "
	rm -rf "endpoints/$1"
	echo_info "Done!"
}

list () {
	if [[ -n $1 ]]; then
		echo_error "Too many arguments."
		echo_info "Usage: tcpvpn list"
		exit 1
	fi
	cd "$APPLICATION_SUPPORT_DIR"
	if [[ ! -d "endpoints" || -z "$( ls -A endpoints )" ]]; then
		echo "No configurations currently exist. Use \`tcpvpn create\` to create a configuration."
		exit 0
	fi
	echo "${CLR_WHITE}Current configurations:${CLR_RESET}"
	for file in "endpoints"/*; do
		echo "- $(basename "$file")"
	done
}

version () {
	if [[ -n $1 ]]; then
		echo_error "Too many arguments."
		echo_info "Usage: tcpvpn version"
		exit 1
	fi
	cd "$APPLICATION_SUPPORT_DIR"
	if [[ ! -f "version" ]]; then
		echo_error "No version found (this should never happen)"
	fi
	echo_info "TCP-VPN version $(cat version)"
}

update () {
	# Process arguments
	f_flag='' # Argument to read from file
	v_flag=''
	while getopts ':f:v:' flag; do
		case "$flag" in
			f) f_flag="$OPTARG" ;;
			v) v_flag="$OPTARG" ;;
			:) echo_error "-$OPTARG requires an argument"; echo_info "Usage: tcpvpn update [-f <source_directory>] [-v <version>]"; exit 1;;
			\?) echo_error "Invalid option -$OPTARG"; echo_info "Usage: tcpvpn update [-f <source_directory>] [-v <version>]"; exit 1;;
		esac
	done
	if [[ -n "$f_flag" && ! -d "$f_flag" ]]; then
		echo_error "Directory \"$f_flag\" does not exist."
		exit 1
	fi
	# curl -fsL https://raw.githubusercontent.com/coolcoder067/TCP-VPN/refs/heads/main/install/install_client_macos.sh | sudo bash
	if ! script=$(curl -fsL "$INSTALL_SCRIPT_URL"); then
		echo_error "Failed to fetch install script."
	fi
	args=()
	[[ -n "$f_flag" ]] && args+=(-f "$(realpath "$f_flag")")
	[[ -n "$v_flag" ]] && args+=(-v "$v_flag")
	bash -c "$script" _ "${args[@]}" # Pass all arguments (for example -v)
}



# Main logic

set -e

if [[ $(whoami) != "root" ]]; then
	echo_error "This script must be run as root."
	exit 1
fi

case "$1" in
	create) shift; create_endpoint "$@";;
	up) shift; activate_endpoint "$@";;
	down) shift; deactivate_endpoint "$@";;
	uninstall) shift; uninstall "$@";;
	export) shift; export_conf "$@";;
	delete) shift; delete "$@";;
	list) shift; list "$@";;
	version) shift; version "$@";;
	update) shift; update "$@";;
	*)
		if [[ -n "$1" ]]; then
			echo_error "Unknown command \"$1\"."
		fi
		echo -e "\
${CLR_WHITE}\
Usage:\n\
Manage configurations\n\
${CLR_RESET}\
    tcpvpn create [-f <filepath>]\n\
    tcpvpn delete <name>\n\
    tcpvpn export <name>\n\
    tcpvpn list\n\
${CLR_WHITE}\
Activate/deactivate the VPN\n\
${CLR_RESET}\
    tcpvpn up <name>\n\
    tcpvpn down <name>\n\
${CLR_WHITE}\
Manage the installation\n\
${CLR_RESET}\
    tcpvpn version\n\
    tcpvpn update\n\
    tcpvpn uninstall"
		exit 1
		;;
esac



