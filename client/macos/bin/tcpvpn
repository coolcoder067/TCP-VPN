#!/bin/bash

APPLICATION_SUPPORT_DIR="~/Library/Application Support/tcpvpn"
BIN_DIRECTORY="/usr/local/bin/tcpvpn"
LIB_DIRECTORY="/usr/local/lib/tcpvpn"

CLR_WHITE="\033[1;37m"
CLR_YELLOW="\033[1;33m"
CLR_RED="\033[1;31m"
CLR_RESET="\033[0m"


echo_info() {
  echo -e "${CLR_WHITE}[Info] $*${CLR_RESET}"
}

echo_warn() {
  echo -e "${CLR_YELLOW}[Warn] $*${CLR_RESET}"
}

echo_error() {
  echo -e "${CLR_RED}[Error] $*${CLR_RESET}"
}


create_endpoint () {
  f_flag='' # Argument to read from file
  while getopts 'f:' flag; do
    case "${flag}" in
      f) f_flag="${OPTARG}" ;;
    esac
  done
  if [[ -n "$f_flag" ]]; then
    source "$f_flag"
  fi

  cd "$APPLICATION_SUPPORT_DIR"

  # Take input from user
  if [[ -z "${ENDPOINT_ADDRESS// }" ]]; then
    echo -ne 'What is the address of VPN server?\n> '
    read ENDPOINT_ADDRESS
  else
    echo_info 'Reading ENDPOINT_ADDRESS from provided file.'
  fi
  if [[ -z "${ENDPOINT_ADDRESS// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi
  # RESOLVE_WITH_DNS
  if [[ -z "${RESOLVE_WITH_DNS// }" ]]; then
    echo -ne "Does this address need to be resolved with DNS? Answer with 'true' or 'false'.\n> "
    read RESOLVE_WITH_DNS
  else
    echo_info 'Reading RESOLVE_WITH_DNS from provided file.'
  fi
  if [[ -z "${RESOLVE_WITH_DNS// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi
  if [[ "$RESOLVE_WITH_DNS" != "true" && "$RESOLVE_WITH_DNS" != "false" ]]; then
    echo_error "Please enter 'true' or 'false' exactly."
    exit 1
  fi

  # ENDPOINT_PORT
  if [[ -z "${ENDPOINT_PORT// }" ]]; then
    echo -ne 'What is the port that the server is listening on?\n> '
    read ENDPOINT_PORT
  else
    echo_info 'Reading ENDPOINT_PORT from provided file.'
  fi
  if [[ -z "${ENDPOINT_PORT// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi

  # USER_PRIVATE_KEY
  if [[ -z "${USER_PRIVATE_KEY// }" ]]; then
    echo -ne 'What is the PRIVATE key of YOUR USER?\n> '
    read USER_PRIVATE_KEY
  else
    echo_info 'Reading USER_PRIVATE_KEY from provided file.'
  fi
  if [[ -z "${USER_PRIVATE_KEY// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi

  # SERVER_PUBLIC_KEY
  if [[ -z "${SERVER_PUBLIC_KEY// }" ]]; then
    echo -ne 'What is the PUBLIC key of the SERVER?\n> '
    read SERVER_PUBLIC_KEY
  else
    echo_info 'Reading SERVER_PUBLIC_KEY from provided file.'
  fi
  if [[ -z "${SERVER_PUBLIC_KEY// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi

  # UDP2RAW_PWD
  if [[ -z "${UDP2RAW_PWD// }" ]]; then
    echo -ne 'What is the password for udp2raw?\n> '
    read UDP2RAW_PWD
  else
    echo_info 'Reading UDP2RAW_PWD from provided file.'
  fi
  if [[ -z "${UDP2RAW_PWD// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi

  # USER_ADDRESS
  if [[ -z "${USER_ADDRESS// }" ]]; then
    echo -ne "Enter the IP addresses allocated to your user, separated by comma.\nThis should look like '10.0.0.2/24, fd42:42:42::2/64'.\n> "
    read USER_ADDRESS
  else
    echo_info 'Reading USER_ADDRESS from provided file.'
  fi
  if [[ -z "${USER_ADDRESS// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi

  # DNS_SERVERS
  if [[ -z "${DNS_SERVERS// }" ]]; then
    echo -ne "Enter the DNS servers you want to use, separated by comma, or leave blank.\nThe default is '1.1.1.1, 2606:4700:4700::1111'.\n> "
    read DNS_SERVERS
  else
    echo_info 'Reading DNS_SERVERS from provided file.'
  fi
  if [[ -z "$DNS_SERVERS" ]]; then
    DNS_SERVERS='1.1.1.1, 2606:4700:4700::1111'
  fi

  # WIREGUARD_PORT
  if [[ -z "${WIREGUARD_PORT// }" ]]; then
    echo -ne "Choose an empty port where wireguard and udp2raw can communicate. (ex. 50001)\n> "
    read WIREGUARD_PORT
  else
    echo_info 'Reading WIREGUARD_PORT from provided file.'
  fi
  if [[ -z "${WIREGUARD_PORT// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi

  # UDP2RAW_PORT
  if [[ -z "${UDP2RAW_PORT// }" ]]; then
    echo -ne "Choose an empty port where udp2raw can communicate with the server. (ex. 50002)\n> "
    read UDP2RAW_PORT
  else
    echo_info 'Reading UDP2RAW_PORT from provided file.'
  fi
  if [[ -z "${UDP2RAW_PORT// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi

  # CONFIGURATION_NAME
  if [[ -z "${CONFIGURATION_NAME// }" ]]; then
    echo -ne 'What is the name of your new VPN configuration? Keep it short.\n> '
    read CONFIGURATION_NAME
  else
    echo_info 'Reading CONFIGURATION_NAME from provided file.'
  fi
  if [[ -z "${CONFIGURATION_NAME// }" ]]; then
    echo_error "Input cannot be blank."
    exit 1
  fi


  
  CONFIGURATION_DIR="$APPLICATION_SUPPORT_DIR/endpoints/$CONFIGURATION_NAME"
  if [[ -d $CONFIGURATION_DIR ]]; then
    echo_warn "This will overwrite the contents of $CONFIGURATION_DIR."
  fi
  echo 'Press enter to confirm the details above, or CTRL+C to quit.'
  read

  # Make directory
  rm -rf $CONFIGURATION_DIR
  mkdir -p "$CONFIGURATION_DIR"

  # Generate script_env.cfg
  echo -ne "ENDPOINT_ADDRESS='$ENDPOINT_ADDRESS'\nRESOLVE_WITH_DNS='$RESOLVE_WITH_DNS'\n\
    ENDPOINT_PORT='$ENDPOINT_PORT'\nUSER_PRIVATE_KEY='$USER_PRIVATE_KEY'\nSERVER_PUBLIC_KEY='$SERVER_PUBLIC_KEY'\n\
    UDP2RAW_PWD='$UDP2RAW_PWD'\nUSER_ADDRESS='$USER_ADDRESS'\nDNS_SERVERS='$DNS_SERVERS'\n\
    WIREGUARD_PORT='$WIREGUARD_PORT'\nUDP2RAW_PORT='$UDP2RAW_PORT'\nCONFIGURATION_NAME='$CONFIGURATION_NAME'\
    " > $CONFIGURATION_DIR/script_env.cfg

  # Generate wg.conf
  echo -ne "[Interface]\nPrivateKey = $USER_PRIVATE_KEY\n\
  Address = $USER_ADDRESS\nDNS = $DNS_SERVERS\nMTU = 1342\n\n\
  PreUp = '$LIB_DIRECTORY/PreUp.sh' '$CONFIGURATION_DIR'\n\
  PostUp = '$LIB_DIRECTORY/PostUp.sh' '$CONFIGURATION_DIR'\n\
  PostDown = '$LIB_DIRECTORY/PostDown.sh' '$CONFIGURATION_DIR'\n\n\
  [Peer]\nPublicKey = $SERVER_PUBLIC_KEY\nAllowedIPs = 0.0.0.0/0, ::/0\n\
  Endpoint = 127.0.0.1:$WIREGUARD_PORT" > $CONFIGURATION_DIR/wg.conf

  echo -e "Generated files at $CONFIGURATION_DIR.\nUse \`sudo tcpvpn up $CONFIGURATION_NAME\` to activate your VPN."
}

activate_endpoint () {
  if [[ -z "$1" ]]; then
    echo "Usage: tcpvpn up <name>"
    exit 1
  fi
  cd "$APPLICATION_SUPPORT_DIR"
  if [[ -f active ]]; then
    echo_error "VPN already active. Use \`tcpvpn down\` to deactivate."
    exit 1
  fi
  FILEPATH="endpoints/$1/wg.conf"
  if [[ ! -f $FILEPATH ]]; then
    echo_error "No configuration exists for \"$1\". Use \`tcpvpn create\` to create a configuration."
    exit 1
  fi
  echo_info "Activating configuration '$1'..."
  wg-quick up "$FILEPATH" > "endpoints/$1/wg.log" 2>&1
  echo $1 > active
}


deactivate_endpoint () {
  cd "$APPLICATION_SUPPORT_DIR"
  if [[ ! -f active ]]; then
    echo_error "The VPN is not active. Use \`tcpvpn up <name>\` to activate."
    exit 1
  fi
  ACTIVE_VPN=$(cat active)
  FILEPATH="endpoints/$ACTIVE_VPN/wg.conf"
  if [[ ! -f $FILEPATH ]]; then
    echo_error "No file was found at $(pwd)/$FILEPATH."
    exit 1
  fi
  echo_info "Deactivating configuration '$1'..."
  wg-quick down "$FILEPATH" > "endpoints/$ACTIVE_VPN/wg.log" 2>&1
  rm active
}

uninstall () {
  echo_warn 'This option will uninstall the tool completely, erasing all VPN configurations. Type "Yes" exactly to continue.\n> '
  read YES_OPTION
  if [[ "$YES_OPTION" = "Yes" ]]; then
    echo_info "Uninstalling..."
    rm -rf "$LIB_DIRECTORY"
    rm -rf "$APPLICATION_SUPPORT_DIR"
    rm -rf "$BIN_DIRECTORY"
    echo_info "Done!"
  else
    echo_info "Abort."
  fi
}

export () {
  cd "$APPLICATION_SUPPORT_DIR"
  if [[ ! -f "endpoints/$1/script_env.cfg" ]]; then
    echo_error "No configuration exists for \"$1\". Use \`tcpvpn create\` to create a configuration."
    exit 1
  fi
  cat "endpoints/$1/script_env.cfg"
}

delete () {
  cd "$APPLICATION_SUPPORT_DIR"
  if [[ ! -d "endpoints/$1" ]]; then
    echo_error "No configuration exists for \"$1\". Use \`tcpvpn create\` to create a configuration."
    exit 1
  fi
  echo "Press enter to permanently delete configuration \"$1\", or Ctrl+C to quit. "
  read
  rm -rf "endpoints/$1"
}

list () {
  cd "$APPLICATION_SUPPORT_DIR"
  if [[ ! -d "endpoints" ]]; then
    echo "No configurations currently exist. Use \`tcpvpn create\` to create a configuration."
    exit 0
  fi
  echo "Current configurations:"
  for file in "endpoints"/*; do
    echo $file
  done
}

# Main logic

set -e

if [[ $(whoami) != "root" ]]; then
  echo "Error: This script must be run as root."
  exit 1
fi

case "$1" in
  create) shift; create_endpoint "$@";;
  up) shift; activate_endpoint "$@";;
  down) shift; deactivate_endpoint "$@";;
  *)
    echo -e "Usage: tcpvpn create [-f <filepath>]\n       tcpvpn up <name>\n       tcpvpn down\n       tcpvpn uninstall\n       tcpvpn export <name>\n       tcpvpn delete <name>\n       tcpvpn list"
    exit 1
    ;;
esac



